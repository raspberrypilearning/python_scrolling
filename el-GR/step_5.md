## Î•Ï€Î¹Ï„Î¬Ï‡Ï…Î½Îµ!

<div style="display: flex; flex-wrap: wrap">
<div style="flex-basis: 200px; flex-grow: 1; margin-right: 15px;">
Î¤Î± Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ± Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹Î± Î±Ï„ÎµÎ»ÎµÎ¯Ï‰Ï„Ï‰Î½ Î´ÏÎ¿Î¼Î­Ï‰Î½ Î±Ï…Î¾Î¬Î½Î¿Ï…Î½ Ï„Î· Î´Ï…ÏƒÎºÎ¿Î»Î¯Î± Ï„Î¿Ï… Ï€Î±Î¹Ï‡Î½Î¹Î´Î¹Î¿Ï ÏŒÏƒÎ¿ Ï€ÏÎ¿Î¿Î´ÎµÏÎµÎ¹ Î¿ Ï€Î±Î¯ÎºÏ„Î·Ï‚ ÎºÎ±Î¹ Ï„Î¿Ï… Î´Î¯Î½Î¿Ï…Î½ Î²Î±Î¸Î¼Î¿Î»Î¿Î³Î¯Î±.
</div>
<div>

![Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î± Î­ÏÎ³Î¿Ï… Î¼Îµ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î³Î¹Î± Ï„Î¿ ÏƒÎºÎ¿Ï ÏƒÏ„Î·Î½ Î¿Î¸ÏŒÎ½Î·.](images/score.png){:width="300px"}

</div>
</div>

### Î ÏÏŒÏƒÎ¸ÎµÏƒÎµ ÎµÏ€Î¯Ï€ÎµÎ´Î± Î´Ï…ÏƒÎºÎ¿Î»Î¯Î±Ï‚

Î— Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î¾ÎµÎºÎ¬Î¸Î±ÏÏ‰Î½ ÎµÏ€Î¹Ï€Î­Î´Ï‰Î½ Î´Ï…ÏƒÎºÎ¿Î»Î¯Î±Ï‚ Î¸Î± Î´Î¹ÎµÏ…ÎºÎ¿Î»ÏÎ½ÎµÎ¹ Ï„Î¿Î½ Ï€Î±Î¯ÎºÏ„Î· ÏƒÎ¿Ï… Î½Î± ÎºÎ±Ï„Î±Î»Î¬Î²ÎµÎ¹ Ï„Î¹ ÏƒÏ…Î¼Î²Î±Î¯Î½ÎµÎ¹.

--- task ---

Î”Î·Î¼Î¹Î¿ÏÏÎ³Î·ÏƒÎµ Î¼Î¹Î± `global` Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® `level` Î³Î¹Î± Î½Î± Ï€Î±ÏÎ±ÎºÎ¿Î»Î¿Ï…Î¸ÎµÎ¯Ï‚ Ï„Î¿ ÎµÏ€Î¯Ï€ÎµÎ´Î¿ ÏƒÏ„Î¿ Î¿Ï€Î¿Î¯Î¿ Î²ÏÎ¯ÏƒÎºÎµÏ„Î±Î¹ Î±Ï…Ï„Î®Î½ Ï„Î· ÏƒÏ„Î¹Î³Î¼Î® Î¿ Ï€Î±Î¯ÎºÏ„Î·Ï‚. ÎŒÏÎ¹ÏƒÎµ Ï‰Ï‚ Î±ÏÏ‡Î¹ÎºÎ® Ï„Î¹Î¼Î® Ï„Î¿ `1`, ÏÏƒÏ„Îµ Î¿Î¹ Ï€Î±Î¯ÎºÏ„ÎµÏ‚ Î½Î± Î¾ÎµÎºÎ¹Î½Î¿ÏÎ½ Î­Î½Î± Î½Î­Î¿ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹ ÏƒÏ„Î¿ Ï€ÏÏÏ„Î¿ ÎµÏ€Î¯Ï€ÎµÎ´Î¿.

--- code ---
---
language: python filename: main.py
line_highlights: 7
---

# Î”Î®Î»Ï‰ÏƒÎ· Ï„Ï‰Î½ ÎºÎ±Î¸Î¿Î»Î¹ÎºÏÎ½ Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏÎ½ ÎµÎ´Ï
level = 1

--- /code ---

--- /task ---

--- task ---

Î‘Ï…Ï„ÏŒÏ‚ Î¿ ÎºÏÎ´Î¹ÎºÎ±Ï‚ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¿ `height` ÎºÎ±Î¹ Ï„Î¿ `frame_count` Î³Î¹Î± Î½Î± Î±Ï…Î¾Î¬Î½ÎµÎ¹ Ï„Î· Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î® `level` ÎºÎ¬Î¸Îµ Ï†Î¿ÏÎ¬ Ï€Î¿Ï… Î¿ Ï€Î±Î¯ÎºÏ„Î·Ï‚ Ï„ÎµÎ»ÎµÎ¹ÏÎ½ÎµÎ¹ Î¼Î¹Î± Î¿Î¸ÏŒÎ½Î· ÎºÎ±Î¹, ÏƒÏ„Î· ÏƒÏ…Î½Î­Ï‡ÎµÎ¹Î±, ÎµÎ¼Ï†Î±Î½Î¯Î¶ÎµÎ¹ Ï„Î¿ Î½Î­Î¿ ÎµÏ€Î¯Ï€ÎµÎ´Î¿ Î³Î¹Î± Ï„Î¿Î½ Ï€Î±Î¯ÎºÏ„Î·.

**Î•Ï€Î¯Î»ÎµÎ¾Îµ:** Î‘Ï…Ï„ÏŒÏ‚ Î¿ ÎºÏÎ´Î¹ÎºÎ±Ï‚ Ï€ÎµÏÎ¹Î¿ÏÎ¯Î¶ÎµÎ¹ Ï„Î± ÎµÏ€Î¯Ï€ÎµÎ´Î± ÏƒÎµ Ï€Î­Î½Ï„Îµ, ÏÏƒÏ„Îµ Î½Î± Î¼Î·Î½ ÎµÎ¯Î½Î±Î¹ Ï€Î¿Î»Ï Î´ÏÏƒÎºÎ¿Î»Î¿ Î½Î± Ï€Î±Î¯Î¾ÎµÎ¹Ï‚. Î”ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ ÎºÎ±Î½Î­Î½Î±Ï‚ Î»ÏŒÎ³Î¿Ï‚ Ï„Î¿ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹ ÏƒÎ¿Ï… Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Î¿Ï€Ï‰ÏƒÎ´Î®Ï€Î¿Ï„Îµ Ï€Î­Î½Ï„Îµ, Î±Î»Î»Î¬ Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÏ€Î¹Î»Î­Î¾ÎµÎ¹Ï‚ Î­Î½Î± ÏŒÏÎ¹Î¿. ÎŸÎ¹ Î¬Î½Î¸ÏÏ‰Ï€Î¿Î¹ Î¼Ï€Î¿ÏÎ¿ÏÎ½ Î½Î± ÎºÎ¹Î½Î·Î¸Î¿ÏÎ½ Î³ÏÎ®Î³Î¿ÏÎ± Î¼ÏŒÎ½Î¿ Î¼Î­Ï‡ÏÎ¹ Î­Î½Î± ÏŒÏÎ¹Î¿!

--- code ---
---
language: python
filename: main.py â€” draw_obstacles()
---

def draw_obstacles():

    if frame_count % height == height - 1 and level < 5:
        level += 1
        print('You have reached level', level)

--- /code ---

--- /task ---

--- task ---

The two main options for increasing difficulty are to make the game move faster, and to increase the number of obstacles.

--- collapse ---
---
title: Î•Ï€Î¹Ï„Î¬Ï‡Ï…Î½Îµ Ï„Î¿ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹ ÏƒÎ¿Ï…
---

The speed of the game is controlled by how fast obstacles seem to be moving towards the player. This code speeds this up by adding `frame_count * level` to the `y` coordinate during obstacle generation.

Instead of moving your obstacles by one pixel in every frame, this code effectively moves it by `level` pixels instead.

Looking at the code, you might expect the speed to increase by more than `level` pixels. For example, at the point just before your `level` increases, the `frame_count` is `799` â€” as the `level` increases one frame before the `frame_count` is an even multiple of `height` (set at `400` pixels) â€” and `799 * 3` is notably bigger than `799 * 2`. However, the extra pixels created by multiplying the whole of `frame_count` by a bigger number are hidden by `ob_y %= height`. This leaves only the `level` extra pixels in each step.

--- code ---
---
language: python filename: main.py â€” draw_obstacles()
line_numbers: false
---

    for i in range(6):
        ob_x = randint(0, height)
        ob_y = randint(0, height) + (frame_count * level)
        ob_y %= height  # Wrap around
        text('ğŸŒµ', ob_x, ob_y)

--- /code ---

--- /collapse ---

--- collapse ---
---
title: Î ÏÏŒÏƒÎ¸ÎµÏƒÎµ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ± ÎµÎ¼Ï€ÏŒÎ´Î¹Î±
---

Adding extra obstacles is just a matter of increasing the number of times the `for` loop that creates them runs. You can do this by increasing the number you pass to the `range()` function by `level`.

**Tip:** Of course, you can always use `level * 2`, or even larger multiples, if you want to make your game harder.

--- /collapse ---

--- /task ---

### ÎšÏÎ¬Ï„Î± Ï„Î¿ ÏƒÎºÎ¿Ï

The longer a player lasts without colliding with an obstacle, the better they're playing your game. Adding a score will let them see how well they're doing.

--- task ---

Create a global `score` variable to track the player's score. Set it to `0` so players start a new game without any points.

--- code ---
---
language: python filename: main.py
line_numbers: false
---

# Î”Î®Î»Ï‰ÏƒÎ· Ï„Ï‰Î½ ÎºÎ±Î¸Î¿Î»Î¹ÎºÏÎ½ Î¼ÎµÏ„Î±Î²Î»Î·Ï„ÏÎ½ ÎµÎ´Ï
score = 0

--- /code ---

--- /task ---

--- task ---

You can increase your player's score for every frame where they have not collided with an obstacle by increasing their score when you check for collision in `draw_player()`.

**Choose:** You can decide how many points each frame is worth, but increasing the player's score by `level` rewards players who can survive at higher difficulty levels.

--- code ---
---
language: python
filename: main.py â€” draw_player()
---

    global score
    
    if collide == safe.hex:
        text('ğŸˆ', mouse_x, player_y)
        score += level
    else:
        text('ğŸ’¥', mouse_x, player_y)

--- /code ---

--- /task ---

--- task ---

Players should be able to see their score. Because it increases so quickly, using `print()` wouldn't work very well. Use the p5 `text()` function inside your `draw()` function, to display it as text on the game screen instead.

[[[processing-python-text]]]

You can use the `+` operator to combine two or more strings if you want to give a heading like 'score' or 'points'. Because `score` is a number, you will need to convert it to a string before you can join it with another string. You can do this with `str()`:

```python
message = 'Score: ' + str(score)
```
**Tip:** `str()` is short for 'string' â€” programmers often remove letters like this, so they don't have to type as much!

--- /task ---

### Î¤Î­Î»Î¿Ï‚ Ï€Î±Î¹Ï‡Î½Î¹Î´Î¹Î¿Ï!

When a player has collided with an obstacle, the game should stop moving and their score should stop increasing.

--- task ---

You can use the `level` variable to signal 'Game over' by setting it to 0 â€” a value it will never reach any other way. Do this in the `else` step of your collision detection code.

--- /task ---

--- task ---

Create an `if` statement in `draw()` that tests whether `level > 0` before calling any of the functions â€” like `background()`, `draw_obstacles()`, and `draw_player()` â€” that update the game. Because these functions are not called, the entire game seems to end, even though your program is still running.

--- /task ---

--- task ---

**Debug:** You might find some bugs in your project that you need to fix. Here are some common bugs.

--- collapse ---
---
title: Î¤Î¿ ÏƒÎºÎ¿Ï Î´ÎµÎ½ ÎµÎ¼Ï†Î±Î½Î¯Î¶ÎµÏ„Î±Î¹
---

Make sure that you've included the `text()` function that draws the player's score at the appropriate point in your `draw()` function, and that you've passed it the correct values:

```python
text('Text to display', x, y)`
```

It should look something like this:

--- code ---
---
language: python
filename: main.py â€” draw()
---

    if level > 0:
        background(safe) 
        fill(255)
        text('Score: ' + str(score), width/2, 20)
        draw_obstacles()
        draw_player()

--- /code ---

--- /collapse ---

--- collapse ---
---
title: Î¤Î¿ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹ Î´ÎµÎ½ ÏƒÏ„Î±Î¼Î±Ï„Î¬ Î¼ÎµÏ„Î¬ Î±Ï€ÏŒ ÏƒÏÎ³ÎºÏÎ¿Ï…ÏƒÎ·
---

If you think your game might not be correctly detecting collisions at all, first try the debug instructions in the previous step, under 'There is no collision when the player reaches an obstacle'.

If your game is correctly detecting collisions, then check that you have properly indented the code that draws your game inside the `if level > 0` statement, to make sure it only runs if that statement is true. For example:

--- code ---
---
language: python
filename: main.py â€” draw()
---

    if level > 0:
        background(safe)
        fill(255)
        text('Score: ' + str(score), width/2, 20)
        draw_obstacles()
        draw_player()

--- /code ---

Finally, if both of those are working correctly, your game may not be setting `level = 0` correctly when a collision happens. For example:

--- code ---
---
language: python
filename: main.py â€” draw_player()
---

    if collide == safe.hex:
        text('ğŸˆ', mouse_x, player_y)
        score += level
    else:
        text('ğŸ’¥', mouse_x, player_y)
        level = 0

--- /code ---

--- /collapse ---

--- collapse ---
---
title: Î¤Î¿ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹ Î´ÎµÎ½ Î³Î¯Î½ÎµÏ„Î±Î¹ Ï€Î¹Î¿ Î³ÏÎ®Î³Î¿ÏÎ¿
---

First, check that `level` is increasing correctly. You should see a message printed out every time it goes up. If this isn't happening, check both the code for printing the message and the code for increasing the level.

If level is increasing correctly, check your `draw_obstacles()` function. In particular, check that you have `ob_y = randint(0, height) + (frame_count * level)`. It should look something like this:

--- code ---
---
language: python filename: main.py â€” draw_obstacles()
line_numbers: false
---

    for i in range(6 + level):
        ob_x = randint(0, height)
        ob_y = randint(0, height) + (frame_count * level)
        ob_y %= height  # Wrap around
        text('ğŸŒµ', ob_x, ob_y)

--- /code ---

--- /collapse ---

--- collapse ---
---
title: Î”ÎµÎ½ ÎµÎ¼Ï†Î±Î½Î¯Î¶Î¿Î½Ï„Î±Î¹ Î½Î­Î± ÎµÎ¼Ï€ÏŒÎ´Î¹Î±
---

There are a few reasons this could be happening. And there are some more reasons why it might appear to be happening, when it isn't. First, because new obstacles are added based on `level`, check that `level` is increasing correctly. You should see a message printed out every time it goes up. If this isn't happening, check both the code for printing the message and the code for increasing the level.

If level is increasing correctly, check your `draw_obstacles()` function to ensure that you have `level` used in the `range()` function of the `for` loop that draws the obstacles. It should look something like this:

--- code ---
---
language: python filename: main.py â€” draw_obstacles()
line_numbers: false
---

    for i in range(6 + level):
        ob_x = randint(0, height)
        ob_y = randint(0, height) + (frame_count * level)
        ob_y %= height  # Wrap around
        text('ğŸŒµ', ob_x, ob_y)

--- /code ---

If you've done all these checks and it still doesn't look like the number of obstacles is increasing, it's possible that they are but you aren't seeing it. You should try some of these steps to test this:
  - Î•Ï€Î¹Î²ÏÎ¬Î´Ï…Î½Îµ Ï„Î¿ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÏÎ½Ï„Î±Ï‚ `frame_rate()` ÏƒÏ„Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· `setup()` Î³Î¹Î± Î½Î± ÏƒÎ¿Ï… Î´ÏÏƒÎµÎ¹ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎ¿ Ï‡ÏÏŒÎ½Î¿ Î³Î¹Î± Î½Î± Î¼ÎµÏ„ÏÎ®ÏƒÎµÎ¹Ï‚

```python
run(frame_rate = 10)
```

language: python filename: main.py â€” draw_obstacles()

  - Change the seed you're using for your random numbers. It's unlikely, but it is possible that some obstacles are randomly appearing directly on top of each other
  - Add a `print()` to the `for` loop in `draw_obstacles()` that prints out the value of `i` in each pass of the loop, so you can verify whether it's running the number of times it should
  - Just for testing purposes, change `range(6 + level)` to `range(6 * level)` â€” that increase should be easier to spot!

--- /collapse ---

--- /task ---

--- save ---
